#!/usr/bin/env node
var fs = require('fs');
var path = require('path');
var kexec = require('kexec');

var FILE_READ_OPTIONS = { encoding: 'utf8' };
var README_FILENAME = '/README';
var HOSTS_FILENAME = '/etc/hosts';
var ORIGINAL_SET_NAME = 'original';
var SET_FILE_EXTENSION_REGEX = /\.set$/;
var TEMPLATE_SET = [
  '# Host set created by hostess',
  '127.0.0.1 localhost',
  '255.255.255.255 broadcasthost',
  '::1             localhost',
  'fe80::1%lo0 localhost'
].join("\n");
var TEMPLATE_README = 'Created by Hostess\nhttps://github.com/shinypb/hostess\n';

// Exit codes
var ERR_WRONG_ARGUMENT_COUNT = 1;
var ERR_INVALID_COMMAND = 2;
var ERR_INVALID_ENVIRONMENT = 3;
var ERR_DIRECTORY_IS_A_FILE = 4;
var ERR_DIRECTORY_CREATE_FAILED = 5;
var ERR_SET_ALREDY_EXISTS = 6;
var ERR_SET_NOT_FOUND = 7;
var ERR_NOT_ROOT = 8;

function validateEnvironment() {
  ['EDITOR', 'HOME'].forEach(function(variableName) {
    if (!process.env[variableName]) {
      console.error("Missing " + variableName + " environment variable.");
      process.exit(ERR_INVALID_ENVIRONMENT);
    }
  });
}

var HOSTESS_DIR = process.env.HOSTESS_DIR || (process.env.HOME + '/.hostess');
function ensureHostessDirectoryExists() {
  if (fs.existsSync(HOSTESS_DIR)) {
    var stats = fs.lstatSync(HOSTESS_DIR);
    if (!stats.isDirectory()) {
      console.error('Configuration path ' + HOSTESS_DIR + ' exists, but is not a directory.');
      process.exit(ERR_DIRECTORY_IS_A_FILE);
    }
  } else {
    fs.mkdirSync(HOSTESS_DIR);
    if (!fs.existsSync(HOSTESS_DIR)) {
      console.log('Failed to create configuration directory at ' + HOSTESS_DIR);
      process.exit(ERR_DIRECTORY_CREATE_FAILED);
    }

    //  Add a readme
    fs.writeFileSync(HOSTESS_DIR + '/' + README_FILENAME, TEMPLATE_README);

    //  Copy the current /etc/hosts file in there
    var originalHostsData = fs.readFileSync(HOSTS_FILENAME);
    fs.writeFileSync(filenameForSet(ORIGINAL_SET_NAME), originalHostsData);
  }
}

function availableSets() {
  return fs.readdirSync(HOSTESS_DIR).filter(function(filename) {
    return !!filename.match(SET_FILE_EXTENSION_REGEX);
  }).map(function(filename) {
    return filename.replace(SET_FILE_EXTENSION_REGEX, '');
  });
}

function filenameForSet(setName) {
  return HOSTESS_DIR + '/' + setName + '.set';
}

function setExists(setName) {
  return availableSets().indexOf(setName) >= 0;
}

function ensureSetExists(setName) {
  if (!setExists(setName)) {
    console.error("There is no set called " + setName + ".");
    console.error("Try 'hostess create " + setName + "' first?");
    return process.exit(ERR_SET_NOT_FOUND);
  }
}

function getSetData(setName) {
  return fs.readFileSync(filenameForSet(setName), FILE_READ_OPTIONS);
}

var commands = {
  _define: function(commandName, usageHint, argumentCount, fn) {
    this._usageHints = (this._usageHints || []).concat(usageHint);
    this[commandName] = function(commandArgs) {
      //  Ensure we've been invoked with the proper number of arguments
      if (commandArgs.length != argumentCount) {
        console.error('Wrong number of arguments for ' + commandName + '.');
        console.log('')
        this.usage();
        process.exit(ERR_WRONG_ARGUMENT_COUNT);
      };
      fn.apply(this, commandArgs);
    }
  },
  usage: function() {
    console.log('usage: hostess [command] [name]');
    console.log('');
    console.log('Commands:');
    this._usageHints.forEach(function(usageHint) {
      console.log('  ' + usageHint);
    });
    console.log('');
  }
};

/*
console.log('  hostess create [name] : creates a new /etc/hosts set with the given name');
console.log('  ');
console.log('  ');
console.log('  ');
console.log('  ');
*/

commands._define(
  'create',
  'hostess create [name]: creates a new /etc/hosts set with the given name',
  1,
  function(setName) {
    if (setExists(setName)) {
      console.error("There is already a set with that name.");
      console.error("Try 'hostess edit " + setName + "' instead?");
      return process.exit(ERR_SET_ALREDY_EXISTS);
    }

    fs.writeFileSync(filenameForSet(setName), TEMPLATE_SET);
    this.edit([setName]);

    console.log('Created a new called ' + setName + '.');
    console.log("Use 'hostess set " + setName + "' to activate it.");
  }
);

commands._define(
  'delete',
  'hostess delete [name] : deletes the /etc/hosts set with the given name',
  1,
  function(setName) {
    ensureSetExists(setName);

    fs.unlinkSync(filenameForSet(setName));
  }
);

commands._define(
  'edit',
  'hostess edit [name]   : edits the /etc/hosts set with the given name',
  1,
  function(setName) {
    ensureSetExists(setName);

    kexec(process.env.EDITOR, [filenameForSet(setName)]);
  }
);
commands._define(
  'list',
  'hostess list          : shows all available set names',
  0,
  function() {
    console.log(availableSets().sort().join('\n'));
  }
);
commands._define(
  'show',
  'hostess show [name]   : prints the contents of the given /etc/hosts set,',
  1,
  function(setName) {
    ensureSetExists(setName);
    console.log(getSetData(setName));
  }
);
commands._define(
  'use',
  'hostess use [name]    : uses the /etc/hosts set with the given name',
  1,
  function(setName) {
    ensureSetExists(setName);
    if (process.getuid() !== 0) {
      console.log("Try 'sudo hostess use " + setName + "' instead.");
      process.exit(ERR_NOT_ROOT);
    }

    fs.writeFileSync(HOSTS_FILENAME, getSetData(setName));
  }
);

var commandName = process.argv[2] || 'usage';
var commandArgs = process.argv.slice(3);
if (commands.hasOwnProperty(commandName)) {
  validateEnvironment();
  ensureHostessDirectoryExists();
  commands[commandName](commandArgs);
} else {
  console.error("Not sure how to " + process.argv[2] + ", sorry. :(");
  process.exit(ERR_INVALID_COMMAND);
}
